\documentclass[a4paper,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{graphicx}


\title{Bloom-Filter: Implementierung und Auswertung}
\author{Daniel Barber \and Tamira Leber}
\date{\today}

\begin{document}

\maketitle

\section*{1. Idee und Funktionsweise}

Ein Bloom-Filter ist eine probabilistische Datenstruktur, die mit sehr wenig Speicher auskommt.
Statt Elemente direkt zu speichern, verwendet er ein Bitfeld der Länge $m$ und $k$
Hashfunktionen.
Beim Einfügen eines Strings werden $k$ Bit-Positionen gesetzt.
Bei einer Abfrage werden dieselben Positionen geprüft:
\begin{itemize}
    \item Wenn mindestens ein Bit 0 ist, ist das Element \emph{sicher nicht} enthalten.
    \item Wenn alle Bits 1 sind, ist das Element \emph{möglicherweise} enthalten (false positive möglich).
\end{itemize}

\textbf{Vorteile:}
\begin{itemize}
    \item Sehr geringer Speicherbedarf
    \item Schnelle Einfüge- und Abfrageoperationen
    \item Einfache Implementierung
\end{itemize}

\textbf{Nachteile:}
\begin{itemize}
    \item False positives sind möglich.
    \item Löschen ist nicht ohne Weiteres möglich (nur mit Counting-Bloom-Filtern)
\end{itemize}

\section*{2. Beispiel aus der Praxis}

Bloom-Filter werden in vielen Anwendungen eingesetzt, in denen schnelle Vorabprüfungen
erforderlich sind.
Ein bekanntes Beispiel ist \textbf{Google Safe Browsing}.
Dort wird ein Bloom-Filter
verwendet, um effizient zu prüfen, ob eine URL möglicherweise auf einer Liste
schädlicher Webseiten steht.
So lassen sich unnötige Netzwerkabfragen reduzieren.

\section*{3. Test der Fehlerrate}

Für die Aufgabe haben wir die Wortliste \texttt{words.txt} verwendet.
Die erwartete Elementanzahl $n$ wurde automatisch aus der Datei bestimmt.
Das Programm erhält einen
gewünschten Fehlerparameter $p$ als Eingabe und berechnet daraus die nötige Filtergrösse $m$
und die optimale Anzahl Hashfunktionen $k$.
Die Berechnung erfolgt mit den Standardformeln:
\[
    m = -\frac{n \ln p}{(\ln 2)^2} \qquad
    k = \frac{m}{n} \ln 2
\]

Als Hashverfahren kam \texttt{murmur3\_128} zum Einsatz, wobei für jede der $k$
Hashfunktionen ein anderer Seed verwendet wurde.

Zur Bestimmung der tatsächlichen Fehlerrate wurden viele zufällige Nicht-Wörter erzeugt und im
Bloom-Filter abgefragt.
Die Anzahl der false positives geteilt durch die Gesamtanzahl der Tests
ergibt die experimentelle Fehlerrate.

\begin{center}
  \includegraphics[width=\textwidth]{output}
\end{center}

\end{document}
